#!/usr/bin/env python3
#
# Copyright 2013 Simone Campagna
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

__author__ = "Simone Campagna"

import os
import re
import sys
import glob
import time
import shutil
import logging
import argparse
import calendar
import datetime
import configparser

class Ask(object):
    def __init__(self, answer='x'):
        self._answer = answer

    def ask(self, question):
        answer = self._answer
        while not answer in 'ANyn':
            answer = input(question + "? ([y]es/[n]o/[A]ll/[N]one) ")

        if answer in 'AN':
            self._answer = answer

        if answer in 'Ay':
            return True
        else:
            return False



class TDelta(object):
    def __init__(self, year=0, month=0, day=0, hour=0, minute=0, second=0):
        self.year = year
        self.month = month
        self.day = day
        self.hour = hour
        self.minute = minute
        self.second = second

    def __add__(self, dt):
        assert isinstance(dt, datetime.datetime)
        return self._make_datetime(
            year=self.year + dt.year, 
            month=self.month + dt.month, 
            day=self.day + dt.day, 
            hour=self.hour + dt.hour, 
            minute=self.minute + dt.minute, 
            second=self.second + dt.second, 
        )

    def __radd__(self, dt):
        assert isinstance(dt, datetime.datetime)
        return self.__add__(dt)

    def __sub__(self, dt):
        assert isinstance(dt, datetime.datetime)
        return self._make_datetime(
            year=self.year - dt.year, 
            month=self.month - dt.month, 
            day=self.day - dt.day, 
            hour=self.hour - dt.hour, 
            minute=self.minute - dt.minute, 
            second=self.second - dt.second, 
        )

    def __rsub__(self, dt):
        assert isinstance(dt, datetime.datetime)
        return self._make_datetime(
            year=dt.year - self.year,
            month=dt.month - self.month,
            day=dt.day - self.day,
            hour=dt.hour - self.hour,
            minute=dt.minute - self.minute,
            second=dt.second - self.second,
        )

    def _norm_month(self, year, month):
        while month < 1:
            month += 12
            year -= 1
        while month > 12:
            month -= 12
            year += 1
        return year, month

    def _make_datetime(self, year, month, day, hour, minute, second):
        while second < 0:
            minute -= 1
            second += 60
        while second >= 60:
            minute += 1
            second -= 60
        while minute < 0:
            hour -= 1
            minute += 60
        while minute >= 60:
            hour += 1
            minute -= 60
        while hour < 0:
            day -= 1
            hour += 24
        while hour >= 24:
            day += 1
            hour -= 24
        year, month = self._norm_month(year, month)
        while day < 1:
            month -= 1
            year, month = self._norm_month(year, month - 1)
            month_days = calendar.monthrange(year, month)[1]
            day += month_days
        year, month = self._norm_month(year, month)
        while True:
            month_days = calendar.monthrange(year, month)[1]
            if day <= month_days:
                break
            year, month = self._norm_month(year, month + 1)
            day -= month_days
        #print(year, month, day, hour, minute, second)
        return datetime.datetime(year, month, day, hour, minute, second)
      
class EntryList(set):
    def __init__(self, list_file, list_dir=None):
        self.list_file = os.path.abspath(list_file)
        if list_dir is None:
            list_dir = os.path.dirname(self.list_file)
        super().__init__()
        with open(self.list_file, "r") as f_in:
            for line in f_in:
                entry = line.strip()
                if not os.path.isabs(entry):
                      entry = os.path.join(list_dir, entry)
                for p_entry in glob.glob(entry):
                    p_entry = os.path.normpath(p_entry)
                    #print("*** {!r} -> {!r}".format(entry, p_entry))
                    self.add(p_entry)

    def __str__(self):
        return repr(self)

    def __repr__(self):
        return "{}(list_file={!r}, {})".format(self.__class__.__name__, self.list_file, super().__repr__())
class HouseKeeper(object):
    MODE_INTERACTIVE = 'interactive'
    MODE_FORCE = 'force'
    MODES = (MODE_FORCE, MODE_INTERACTIVE)
    DEFAULT_MODE = MODE_INTERACTIVE
    DEFAULT_TIME_ATTRIBUTE = "st_mtime"

    TIME_FORMAT = "%Y%m%d %H:%M:%S"
    TIME_FORMATS = (TIME_FORMAT, "%Y%m%d")
    UNIT_ALIASES = {
        'year': ('Y', 'y', 'years'),
        'month': ('M', 'months'),
        'week': ('W', 'w', 'weeks'),
        'day': ('D', 'd', 'days'),
        'hour': ('H', 'h', 'hours'),
        'minute': ('m', 'minutes'),
        'second': ('s', 'seconds'),
    }
    NOW = datetime.datetime.now()
    HOUSEKEEPER_LIST = ".housekeeper.list"
    def __init__(self, logger, *, mode=DEFAULT_MODE, dry_run=False, time_attribute):
        self.logger = logger
        self.mode = mode
        self.dry_run = dry_run
        self.time_attribute = time_attribute
        self.ask_clean = Ask()
        self._visited = set()
        self._re_sep = re.compile('[:,\s]*')
        unit_aliases = []
        self._unit_dict = {}
        for unit, aliases in self.UNIT_ALIASES.items():
            unit_aliases.append(unit)
            unit_aliases.extend(aliases)
            self._unit_dict[unit] = unit
            for alias in aliases:
                self._unit_dict[alias] = unit
        unit_aliases.sort(key=lambda x: len(x), reverse=True)
        #print('([+-]?[1-9]\d+|[+-]?0)\s*({})'.format('|'.join(unit_aliases)))
        self._re_token = re.compile('([+-]?[1-9]\d*|[+-]?0)\s*({})'.format('|'.join(unit_aliases)))
        self._list_dirs = {}

    def _make_datetime(self, ref_date_s):
        # absolute datetime
        for fmt in self.TIME_FORMATS:
            try:
                return datetime.datetime.strptime(ref_date_s, fmt)
            except ValueError:
                pass
        # relative datetime
        s = ref_date_s
        tokens = []
        offset = 0
        while s:
            m_sep = self._re_sep.match(s)
            #print("sep: <{}> -> {}".format(s, m_sep))
            if m_sep:
                b, e = m_sep.span()
                s = s[e:]
                offset += e
            m_token = self._re_token.match(s)
            #print("token: <{}> -> {}".format(s, m_token))
            if m_token:
                b, e = m_token.span()
                s = s[e:]
                offset += e
                tokens.append(m_token.groups())
            else:
                raise ValueError("invalid ref_date {!r}: unparsed token {!r}".format(ref_date_s, ref_date_s[offset:]))
        tdelta = TDelta()
        for num, unit in tokens:
            num = int(num)
            unit = self._unit_dict[unit]
            if unit == 'year':
                tdelta.year += num
            elif unit == 'month':
                tdelta.month += num
            elif unit == 'week':
                tdelta.week += num
            elif unit == 'day':
                tdelta.day += num
            elif unit == 'hour':
                tdelta.hour += num
            elif unit == 'minute':
                tdelta.minute += num
            elif unit == 'second':
                tdelta.second += num
            else:
                raise ValueError("invalid unit {}".format(unit))
        return self.NOW - tdelta

    def clean(self, pattern, ref_date, *, remove_dirs=True, remove_links=True, remove_files=True):
        if not isinstance(ref_date, datetime.datetime):
            ref_date = self._make_datetime(ref_date)
        for entry in glob.glob(pattern):
            entry = os.path.normpath(os.path.abspath(entry))
            if entry in self._visited:
                self.logger.debug("skipping aleady visited entry {}".format(entry))
                continue
            entry_stat = os.stat(entry)
            entry_seconds = getattr(entry_stat, self.time_attribute)
            entry_date = datetime.datetime(*time.localtime(entry_seconds)[:6])
            entry_type = None
            entry_remover = None
            must_remove = True
            list_dirs = []
            if os.path.isdir(entry):
                # dir
                entry_type = 'directory'
                entry_remover = self.remove_dir
                if not remove_dirs:
                    must_remove = False
                list_dirs.append(entry)
            elif os.path.islink(entry):
                # link
                entry_type = 'symbolic link'
                entry_remover = self.remove_link
                if not remove_links:
                    must_remove = False
            elif os.path.isfile(entry):
                # file
                entry_type = 'file'
                entry_remover = self.remove_file
                if not remove_files:
                    must_remove = False
            else:
                self.logger.warning("skipping unmanaged entry {}".format(entry))
                continue
            self._visited.add(entry)
            list_dirs.append(os.path.dirname(entry))
            if not must_remove:
                self.logger.debug("skipping {} {}".format(entry_type, entry))
                continue
            entry_list = None
            for list_dir in list_dirs:
                if list_dir in self._list_dirs:
                    entry_list = self._list_dirs[list_dir]
                else:
                    list_file = os.path.join(list_dir, self.HOUSEKEEPER_LIST)
                    if os.path.exists(list_file):
                        self.logger.debug("reading config file {}".format(list_file))
                        entry_list = EntryList(list_dir=list_dir, list_file=list_file)
                        self._list_dirs[list_dir] = entry_list
                    else:
                        self._list_dirs[list_dir] = None
                if entry_list is not None:
                    break
            if entry_list is not None:
                #print(entry_list)
                if entry in entry_list:
                    must_remove = False    
                    self.logger.debug("skipping {} {} (see {})".format(entry_type, entry, entry_list.list_file))
                    continue
            self.logger.debug("{} {}, {}={!r}, ref_time={!r}".format(entry_type, entry, self.time_attribute, entry_date.strftime(self.TIME_FORMAT), ref_date.strftime(self.TIME_FORMAT)))
            if entry_date < ref_date:
                if self.must_remove("{} {}".format(entry_type, entry), self.mode):
                    entry_remover(entry)
            else:
                self.logger.debug("skipping young {} {}".format(entry_type, entry))
        
    def must_remove(self, message, mode):
        if mode == self.MODE_INTERACTIVE:
            return self.ask_clean.ask("remove {}".format(message))
        elif mode == self.MODE_FORCE:
            return True
        else:
            assert False

    def remove_dir(self, entry):
        if self.dry_run:
            self.logger.warning("DRY-RUN> removing directory {}".format(entry))
        else:
            self.logger.info("removing directory {}".format(entry))
            shutil.rmtree(entry, ignore_errors=True)

    def remove_link(self, entry):
        if self.dry_run:
            self.logger.warning("DRY-RUN> removing symbolic link {}".format(entry))
        else:
            self.logger.info("removing symbolic link {}".format(entry))
            os.remove(entry)

    def remove_file(self, entry):
        if self.dry_run:
            self.logger.warning("DRY-RUN> removing file {}".format(entry))
        else:
            self.logger.info("removing file {}".format(entry))
            os.remove(entry)
            
class HouseKeeperConfig(configparser.ConfigParser):
    def __init__(self):
        super().__init__()
        self['DEFAULT'] = {
            'ref_date': '',
            'remove_dirs': 'True',
            'remove_links': 'True',
            'remove_files': 'True',
        }

def _bool(bool_string):
    if bool_string == "True":
        return True
    elif bool_string == "False":
        return False
    else:
        try:
            i = int(bool_string)
            return bool(i)
        except ValueError:
            raise ValueError("invalid boolean value {!r}".format(bool_string))
def main():
    common_parser = argparse.ArgumentParser(add_help=False)

    common_parser.add_argument("--verbose", "-v",
        action="store_true",
        default=False,
        help="verbose mode")

    common_parser.add_argument("--debug", "-d",
        action="store_true",
        default=False,
        help="debug mode")

    common_parser.add_argument("--dry-run",
        action="store_true",
        default=False,
        help="dry run (do not delete)")

    time_group = common_parser.add_mutually_exclusive_group(required=False)

    time_group.add_argument("--ctime",
        dest="st_time_attribute",
        action="store_const",
        const="st_ctime",
        default=HouseKeeper.DEFAULT_TIME_ATTRIBUTE,
        help="use inode change time")
   
    time_group.add_argument("--mtime",
        dest="st_time_attribute",
        action="store_const",
        const="st_mtime",
        default=HouseKeeper.DEFAULT_TIME_ATTRIBUTE,
        help="use file modification time")
   
    time_group.add_argument("--atime",
        dest="st_time_attribute",
        action="store_const",
        const="st_atime",
        default=HouseKeeper.DEFAULT_TIME_ATTRIBUTE,
        help="use file access time")
   
    mode_group = common_parser.add_mutually_exclusive_group(required=False)

    mode_group.add_argument("--interactive", "-i",
        dest="mode",
        action="store_const",
        const=HouseKeeper.MODE_INTERACTIVE,
        default=HouseKeeper.DEFAULT_MODE,
        help="interactive (ask before deleting)")

    mode_group.add_argument("--force", "-f",
        dest="mode",
        action="store_const",
        const=HouseKeeper.MODE_FORCE,
        default=HouseKeeper.DEFAULT_MODE,
        help="force (delete files without asking)")

    parser = argparse.ArgumentParser(parents=[common_parser])

    parser.add_argument("--config", "-c", 
        type=str,
        metavar="C",
        default=None,
        help="config filename")

    parser.add_argument("--pattern", "-p",
        dest="patterns",
        action="append",
        nargs=2,
        type=str,
        default=[],
        help="add pattern")

    parser.add_argument("--remove-dirs",
        dest="remove_dirs",
        action="store_true",
        default=True,
        help="remove directories")
    parser.add_argument("--ignore-dirs",
        dest="remove_dirs",
        action="store_false",
        default=True,
        help="do not remove directories")

    parser.add_argument("--remove-links",
        dest="remove_links",
        action="store_true",
        default=True,
        help="remove links")
    parser.add_argument("--ignore-links",
        dest="remove_links",
        action="store_false",
        default=True,
        help="do not remove links")

    parser.add_argument("--remove-files",
        dest="remove_files",
        action="store_true",
        default=True,
        help="remove files")
    parser.add_argument("--ignore-files",
        dest="remove_files",
        action="store_false",
        default=True,
        help="do not remove files")

    args = parser.parse_args()

    logger = logging.getLogger("CLEAN_DIRS")
    handler = logging.StreamHandler()
    log_level = logging.WARNING
    if args.debug:
        log_level = logging.DEBUG
    elif args.verbose:
        log_level = logging.INFO
    else:
        log_level = logging.WARNING
    logger.addHandler(handler)
    logger.setLevel(log_level)
    handler.setLevel(log_level)

    try:
        pl = []
        if args.config:
            config = HouseKeeperConfig()
            config.read(args.config)
            for pattern, pattern_data in config.items():
                if not os.path.isabs(pattern):
                    pattern = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(args.config)), pattern))
                ref_date = pattern_data['ref_date']
                remove_dirs = _bool(pattern_data['remove_dirs'])
                remove_links = _bool(pattern_data['remove_links'])
                remove_files = _bool(pattern_data['remove_files'])
                pl.append((pattern, ref_date, remove_dirs, remove_links, remove_files))
        if args.patterns:
            for pattern, ref_date in args.patterns:
                pl.append((pattern, ref_date, args.remove_dirs, args.remove_links, args.remove_files))
                #apply_patterns(logger, args.ref_date, *args.patterns)
    
        housekeeper = HouseKeeper(logger=logger, dry_run=args.dry_run, mode=args.mode, time_attribute=args.st_time_attribute)
        for pattern, ref_date, remove_dirs, remove_links, remove_files in pl:
            housekeeper.clean(pattern, ref_date, remove_dirs=remove_dirs, remove_links=remove_links, remove_files=remove_files)
    except Exception as e:
        if args.debug:
            import traceback
            traceback.print_exc()
        logger.critical("ERR: {}: {}".format(e.__class__.__name__, e))
        sys.exit(1)

if __name__ == "__main__":
    main()
